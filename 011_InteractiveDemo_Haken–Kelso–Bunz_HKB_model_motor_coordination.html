<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Haken-Kelso-Bunz (HKB) Model Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f4f4f4; }
    canvas { background: white; border: 1px solid #ccc; }
    .controls { margin-top: 20px; }
    label { display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Haken-Kelso-Bunz (HKB) Model Demo</h1>
  <p>
    The HKB model describes the relative phase dynamics of two coupled oscillators, often used to model human bimanual coordination. 
    The equation is:
  </p>
  <pre>dφ/dt = -a sin(φ) - 2b sin(2φ)</pre>
  <p>Here, φ is the relative phase. Parameters <code>a</code> and <code>b</code> define the coupling strength. You can adjust them below. Stable (attractors) and unstable points are marked dynamically depending on the slope.</p>

  <canvas id="hkbChart" width="600" height="400"></canvas>

  <div class="controls">
    <label>a: <input type="range" id="aSlider" min="0" max="2" step="0.01" value="1"> <span id="aVal">1.00</span></label>
    <label>b: <input type="range" id="bSlider" min="0" max="2" step="0.01" value="0.5"> <span id="bVal">0.50</span></label>
    <button onclick="updateChart()">Update Plot</button>
  </div>

  <script>
    const ctx = document.getElementById('hkbChart').getContext('2d');

    function dphidt(phi, a, b) {
      return -a * Math.sin(phi) - 2 * b * Math.sin(2 * phi);
    }

    function ddphidt(phi, a, b) {
      return -a * Math.cos(phi) - 4 * b * Math.cos(2 * phi);
    }

    function computeHKB(a, b) {
      const data = [];
      for (let phi = -Math.PI; phi <= Math.PI; phi += 0.01) {
        data.push({ x: phi, y: dphidt(phi, a, b) });
      }
      return data;
    }

    function findAttractors(a, b) {
      const points = [];
      let prevVal = dphidt(-Math.PI, a, b);
      for (let phi = -Math.PI + 0.01; phi <= Math.PI; phi += 0.01) {
        const val = dphidt(phi, a, b);
        if (prevVal * val <= 0) {
          const mid = phi - 0.005;
          const slope = ddphidt(mid, a, b);
          const yVal = dphidt(mid, a, b);
          points.push({ x: mid, y: yVal, backgroundColor: slope < 0 ? 'green' : 'red' });
        }
        prevVal = val;
      }
      return points;
    }

    let chart = new Chart(ctx, {
      type: 'scatter',
      data: {
        datasets: [
          {
            label: 'dφ/dt vs φ',
            type: 'line',
            data: computeHKB(parseFloat(document.getElementById('aSlider').value), parseFloat(document.getElementById('bSlider').value)),
            parsing: false,
            borderWidth: 1,
            borderColor: 'blue'
          },
          {
            label: 'Attractors & Unstable Points',
            type: 'scatter',
            data: findAttractors(parseFloat(document.getElementById('aSlider').value), parseFloat(document.getElementById('bSlider').value)),
            parsing: false,
            pointRadius: 6,
            pointBackgroundColor: ctx => ctx.raw.backgroundColor,
            showLine: false
          }
        ]
      },
      options: {
        responsive: false,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'φ (radians)' },
            min: -Math.PI,
            max: Math.PI
          },
          y: {
            title: { display: true, text: 'dφ/dt' }
          }
        }
      }
    });

    function updateChart() {
      const a = parseFloat(document.getElementById('aSlider').value);
      const b = parseFloat(document.getElementById('bSlider').value);
      document.getElementById('aVal').textContent = a.toFixed(2);
      document.getElementById('bVal').textContent = b.toFixed(2);

      chart.data.datasets[0].data = computeHKB(a, b);
      chart.data.datasets[1].data = findAttractors(a, b);
      chart.update();
    }
  </script>
</body>
</html>
