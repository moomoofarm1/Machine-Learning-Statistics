<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Haken-Kelso-Bunz (HKB) Model Demo - Improved</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f4f4f4; }
    canvas { background: white; border: 1px solid #ccc; }
    .controls { margin-top: 20px; }
    label { display: block; margin-top: 10px; }
    .info { margin-top: 20px; padding: 15px; background: white; border: 1px solid #ccc; border-radius: 5px; }
    .stable { color: green; font-weight: bold; }
    .unstable { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Haken-Kelso-Bunz (HKB) Model Demo - Improved</h1>
  <p>
    The HKB model describes the relative phase dynamics of two coupled oscillators, often used to model human bimanual coordination. 
    The equation is:
  </p>
  <pre>dφ/dt = -a sin(φ) - 2b sin(2φ)</pre>
  <p>Here, φ is the relative phase. Parameters <code>a</code> and <code>b</code> define the coupling strength. 
  <span class="stable">Green points</span> are stable fixed points (attractors), 
  <span class="unstable">red points</span> are unstable fixed points (repellers).</p>
  
  <canvas id="hkbChart" width="700" height="400"></canvas>
  
  <div class="controls">
    <label>a: <input type="range" id="aSlider" min="0" max="3" step="0.01" value="1"> <span id="aVal">1.00</span></label>
    <label>b: <input type="range" id="bSlider" min="0" max="3" step="0.01" value="0.5"> <span id="bVal">0.50</span></label>
    <button onclick="updateChart()">Update Plot</button>
  </div>
  
  <div class="info" id="fixedPointsInfo">
    <h3>Fixed Points Analysis</h3>
    <div id="fixedPointsList"></div>
  </div>

  <script>
    // Wait for Chart.js to load
    function initializeChart() {
      if (typeof Chart === 'undefined') {
        console.error('Chart.js failed to load');
        document.body.innerHTML = '<h1>Error: Chart.js failed to load</h1><p>Please refresh the page or check your internet connection.</p>';
        return;
      }
      
      const ctx = document.getElementById('hkbChart').getContext('2d');
    
    // HKB model equation: dφ/dt
    function dphidt(phi, a, b) {
      return -a * Math.sin(phi) - 2 * b * Math.sin(2 * phi);
    }
    
    // Derivative of dφ/dt (for stability analysis)
    function ddphidt(phi, a, b) {
      return -a * Math.cos(phi) - 4 * b * Math.cos(2 * phi);
    }
    
    // Newton-Raphson method to find precise zeros
    function findZero(phi0, a, b, maxIter = 20, tolerance = 1e-10) {
      let phi = phi0;
      for (let i = 0; i < maxIter; i++) {
        const f = dphidt(phi, a, b);
        const df = ddphidt(phi, a, b);
        
        if (Math.abs(f) < tolerance) break;
        if (Math.abs(df) < tolerance) break; // Avoid division by zero
        
        const newPhi = phi - f / df;
        if (Math.abs(newPhi - phi) < tolerance) break;
        phi = newPhi;
      }
      return phi;
    }
    
    // Generate the main curve data
    function computeHKB(a, b) {
      const data = [];
      for (let phi = -Math.PI; phi <= Math.PI; phi += 0.005) {
        data.push({ x: phi, y: dphidt(phi, a, b) });
      }
      return data;
    }
    
    // HKB phase dynamics and its derivative
function dphidt(phi, a, b) {
  return -a * Math.sin(phi) - 2 * b * Math.sin(2 * phi);
}
function ddphidt(phi, a, b) {
  return -a * Math.cos(phi) - 4 * b * Math.cos(2 * phi);
}

// Normalize any angle to the interval (-π, π]
function normalizePhi(phi) {
  // first wrap into [0, 2π)
  let p = ((phi + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
  // then shift to (-π, π]
  p = p - Math.PI;
  // round to avoid floating‐point duplicates
  return Math.round(p * 1e6) / 1e6;
}

// Find all fixed points analytically, classify stability
function findFixedPoints(a, b) {
  const roots = new Set();

  // 1) trivial roots: sinφ=0 ⇒ φ=0, π (≡ -π)
  [0, Math.PI].forEach(phi => {
    roots.add(normalizePhi(phi));
  });

  // 2) non‐trivial roots: -a - 4b cosφ = 0 ⇒ cosφ = -a/(4b)
  if (b !== 0 && Math.abs(a / (4 * b)) <= 1) {
    const arccos = Math.acos(-a / (4 * b));
    [ arccos, -arccos ].forEach(phi => {
      roots.add(normalizePhi(phi));
    });
  }

  // build the output array with stability info
  return Array.from(roots).map(phi => {
    const deriv = ddphidt(phi, a, b);
    const stable = deriv < 0;
    return {
      x: phi,
      y: 0,
      backgroundColor: stable ? 'green' : 'red',
      borderColor:   stable ? 'darkgreen' : 'darkred',
      isStable: stable,
      derivative: deriv
    };
  });
}

    
    // Update the fixed points information display
    function updateFixedPointsInfo(fixedPoints) {
      const listDiv = document.getElementById('fixedPointsList');
      if (fixedPoints.length === 0) {
        listDiv.innerHTML = '<p>No fixed points found in the range [-π, π].</p>';
        return;
      }
      
      let html = '<table style="width: 100%; border-collapse: collapse;">';
      html += '<tr style="border-bottom: 1px solid #ccc;"><th>φ (radians)</th><th>φ (degrees)</th><th>Stability</th><th>Derivative</th></tr>';
      
      fixedPoints.forEach(point => {
        const degrees = (point.x * 180 / Math.PI).toFixed(1);
        const stability = point.isStable ? '<span class="stable">Stable</span>' : '<span class="unstable">Unstable</span>';
        html += `<tr style="border-bottom: 1px solid #eee;">
          <td>${point.x.toFixed(4)}</td>
          <td>${degrees}°</td>
          <td>${stability}</td>
          <td>${point.derivative.toFixed(4)}</td>
        </tr>`;
      });
      html += '</table>';
      listDiv.innerHTML = html;
    }
    
    // Initialize the chart
    let chart = new Chart(ctx, {
      type: 'scatter',
      data: {
        datasets: [
          {
            label: 'dφ/dt vs φ',
            type: 'line',
            data: computeHKB(parseFloat(document.getElementById('aSlider').value), parseFloat(document.getElementById('bSlider').value)),
            parsing: false,
            borderWidth: 2,
            borderColor: 'blue',
            fill: false,
            pointRadius: 0
          },
          {
            label: 'Zero Line',
            type: 'line',
            data: [{x: -Math.PI, y: 0}, {x: Math.PI, y: 0}],
            parsing: false,
            borderWidth: 1,
            borderColor: 'gray',
            borderDash: [5, 5],
            fill: false,
            pointRadius: 0
          },
          {
            label: 'Fixed Points',
            type: 'scatter',
            data: findFixedPoints(parseFloat(document.getElementById('aSlider').value), parseFloat(document.getElementById('bSlider').value)),
            parsing: false,
            pointRadius: 8,
            pointBackgroundColor: ctx => ctx.raw.backgroundColor,
            pointBorderColor: ctx => ctx.raw.borderColor,
            pointBorderWidth: 2,
            showLine: false
          }
        ]
      },
      options: {
        responsive: false,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'φ (radians)' },
            min: -Math.PI,
            max: Math.PI,
            ticks: {
              callback: function(value) {
                if (value === -Math.PI) return '-π';
                if (value === -Math.PI/2) return '-π/2';
                if (value === 0) return '0';
                if (value === Math.PI/2) return 'π/2';
                if (value === Math.PI) return 'π';
                return value.toFixed(1);
              }
            }
          },
          y: {
            title: { display: true, text: 'dφ/dt' },
            grid: {
              color: function(context) {
                return context.tick.value === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)';
              }
            }
          }
        },
        plugins: {
          legend: {
            display: true
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                if (context.datasetIndex === 2) {
                  const point = context.raw;
                  const degrees = (point.x * 180 / Math.PI).toFixed(1);
                  const stability = point.isStable ? 'Stable' : 'Unstable';
                  return `${stability} fixed point at φ = ${point.x.toFixed(4)} (${degrees}°)`;
                }
                return context.dataset.label + ': (' + context.parsed.x.toFixed(3) + ', ' + context.parsed.y.toFixed(3) + ')';
              }
            }
          }
        }
      }
    });
    
    // Update chart function
    function updateChart() {
      const a = parseFloat(document.getElementById('aSlider').value);
      const b = parseFloat(document.getElementById('bSlider').value);
      document.getElementById('aVal').textContent = a.toFixed(2);
      document.getElementById('bVal').textContent = b.toFixed(2);
      
      const fixedPoints = findFixedPoints(a, b);
      
      chart.data.datasets[0].data = computeHKB(a, b);
      chart.data.datasets[2].data = fixedPoints;
      chart.update();
      
      updateFixedPointsInfo(fixedPoints);
    }
    
    // Initialize with current values
    updateChart();
    
    // Add event listeners for real-time updates
    document.getElementById('aSlider').addEventListener('input', updateChart);
    document.getElementById('bSlider').addEventListener('input', updateChart);
    
    // Make updateChart globally accessible for the button
    window.updateChart = updateChart;
    }
    
    // Initialize when the page loads
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeChart);
    } else {
      initializeChart();
    }
  </script>
</body>
</html>
